"""\nVideo streaming module for LAN Collaboration App\nHandles webcam capture, compression, transmission, and receiving of video frames\n"""\n\nimport cv2\nimport socket\nimport numpy as np\nimport sys\nimport os\nimport threading\nimport time\n\n# Add parent directory to path to import shared modules\nsys.path.append(os.path.join(os.path.dirname(__file__), '..'))\n\nfrom shared.constants import (\n    SERVER_IP, VIDEO_PORT, VIDEO_BUFFER_SIZE,\n    VIDEO_WIDTH, VIDEO_HEIGHT, VIDEO_FPS, VIDEO_QUALITY\n)\nfrom shared.protocol import VIDEO\nfrom shared.helpers import pack_message\n\n\nclass VideoStreamer:\n    """Handles video capture and transmission"""\n    \n    def __init__(self, server_ip=SERVER_IP, server_port=VIDEO_PORT):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, VIDEO_BUFFER_SIZE)\n        self.running = False\n        self.cap = None\n        \n    def start_streaming(self):\n        """Capture webcam frames and stream them to server"""\n        self.cap = cv2.VideoCapture(0)\n        \n        if not self.cap.isOpened():\n            print("Error: Could not open webcam")\n            return\n        \n        # Set resolution\n        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, VIDEO_WIDTH)\n        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, VIDEO_HEIGHT)\n        self.cap.set(cv2.CAP_PROP_FPS, VIDEO_FPS)\n        \n        self.running = True\n        frame_count = 0\n        start_time = time.time()\n        \n        print(f"Starting video stream to {self.server_ip}:{self.server_port}")\n        print("Press 'q' to quit")\n        \n        try:\n            while self.running:\n                ret, frame = self.cap.read()\n                \n                if not ret:\n                    print("Error: Failed to capture frame")\n                    break\n                \n                # Compress frame to JPEG\n                compressed_frame = self.compress_frame(frame)\n                \n                # Pack message with protocol header\n                packet = pack_message(VIDEO, compressed_frame)\n                \n                # Send via UDP\n                try:\n                    self.sock.sendto(packet, (self.server_ip, self.server_port))\n                except Exception as e:\n                    print(f"Error sending frame: {e}")\n                \n                # Display local preview\n                cv2.imshow('Video Stream - Sending', frame)\n                \n                # Calculate and display FPS\n                frame_count += 1\n                if frame_count % 30 == 0:\n                    elapsed = time.time() - start_time\n                    fps = frame_count / elapsed\n                    print(f"Streaming at {fps:.2f} FPS | Packet size: {len(packet)} bytes")\n                \n                # Control frame rate\n                if cv2.waitKey(int(1000/VIDEO_FPS)) & 0xFF == ord('q'):\n                    break\n                    \n        finally:\n            self.stop_streaming()\n    \n    def compress_frame(self, frame):\n        """Compress frame to JPEG bytes"""\n        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), VIDEO_QUALITY]\n        result, encoded_frame = cv2.imencode('.jpg', frame, encode_param)\n        \n        if not result:\n            raise Exception("Failed to encode frame")\n        \n        return encoded_frame.tobytes()\n    \n    def stop_streaming(self):\n        """Clean up resources"""\n        self.running = False\n        if self.cap:\n            self.cap.release()\n        cv2.destroyAllWindows()\n        self.sock.close()\n        print("Video streaming stopped")\n\n\nclass VideoReceiver:\n    """Handles receiving and displaying video streams"""\n    \n    def __init__(self, listen_port=VIDEO_PORT):\n        self.listen_port = listen_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, VIDEO_BUFFER_SIZE)\n        self.running = False\n        \n    def start_receiving(self):\n        """Receive and display video frames"""\n        try:\n            self.sock.bind(('0.0.0.0', self.listen_port))\n            print(f"Listening for video on port {self.listen_port}")\n            print("Press 'q' to quit")\n            \n            self.running = True\n            frame_count = 0\n            start_time = time.time()\n            \n            while self.running:\n                try:\n                    # Receive packet\n                    data, addr = self.sock.recvfrom(VIDEO_BUFFER_SIZE)\n                    \n                    # Decompress and display frame\n                    frame = self.decompress_frame(data)\n                    \n                    if frame is not None:\n                        cv2.imshow(f'Video Stream - Receiving from {addr[0]}', frame)\n                        \n                        # Calculate and display FPS\n                        frame_count += 1\n                        if frame_count % 30 == 0:\n                            elapsed = time.time() - start_time\n                            fps = frame_count / elapsed\n                            print(f"Receiving at {fps:.2f} FPS from {addr[0]}:{addr[1]}")\n                    \n                    # Check for quit\n                    if cv2.waitKey(1) & 0xFF == ord('q'):\n                        break\n                        \n                except socket.timeout:\n                    continue\n                except Exception as e:\n                    print(f"Error receiving frame: {e}")\n                    \n        finally:\n            self.stop_receiving()\n    \n    def decompress_frame(self, data):\n        """Decompress JPEG bytes to frame"""\n        try:\n            # Skip protocol header (12 bytes) and decode the payload\n            from shared.helpers import unpack_message\n            version, msg_type, payload_length, seq_num, payload = unpack_message(data)\n            \n            # Decode JPEG\n            nparr = np.frombuffer(payload, np.uint8)\n            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n            \n            return frame\n        except Exception as e:\n            print(f"Error decompressing frame: {e}")\n            return None\n    \n    def stop_receiving(self):\n        """Clean up resources"""\n        self.running = False\n        cv2.destroyAllWindows()\n        self.sock.close()\n        print("Video receiving stopped")\n\n\ndef main():\n    """Main function for testing video streaming"""\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='LAN Video Streaming')\n    parser.add_argument('mode', choices=['send', 'receive'], \n                       help='Mode: send (stream webcam) or receive (display stream)')\n    parser.add_argument('--ip', default='127.0.0.1', \n                       help='Server IP address (for sender mode)')\n    parser.add_argument('--port', type=int, default=VIDEO_PORT,\n                       help=f'Port number (default: {VIDEO_PORT})')\n    \n    args = parser.parse_args()\n    \n    if args.mode == 'send':\n        streamer = VideoStreamer(server_ip=args.ip, server_port=args.port)\n        streamer.start_streaming()\n    elif args.mode == 'receive':\n        receiver = VideoReceiver(listen_port=args.port)\n        receiver.start_receiving()\n\n\nif __name__ == '__main__':\n    main()